---
phase: 03-playback-controls
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - index.html
  - src/core/cameraPresets.ts
  - src/main.ts
  - src/ui/PlaybackOverlay.ts
  - src/style.css
autonomous: true
requirements: [VIEW-04, VIEW-05, VIEW-06]

must_haves:
  truths:
    - "User can tap 0.5x / 1x / 2x speed buttons and the animation visibly changes pace"
    - "User can click Front, Left, Right, or Back preset buttons and the camera smoothly animates to that angle (~300ms)"
    - "User can drag a timeline slider to scrub frame-by-frame and releasing resumes playback from that position"
    - "Control bar appears as a single row below the 3D canvas with Play/Pause | Timeline | Speed | Camera presets layout"
    - "Active speed button is visually highlighted; inactive buttons are subtle"
    - "Timeline slider shows accent-colored fill for elapsed portion and muted gray for remainder"
  artifacts:
    - path: "src/core/cameraPresets.ts"
      provides: "Smooth camera lerp animation with 4 presets (front/left/right/back)"
      exports: ["setCameraPreset", "tickCameraAnimation", "registerControls", "PresetName"]
    - path: "src/ui/PlaybackOverlay.ts"
      provides: "Single-row control bar UI with all playback controls"
      exports: ["mountPlaybackOverlay"]
    - path: "index.html"
      provides: "Flex-col wrapper around panel-center + control-bar container"
      contains: "id=\"control-bar\""
    - path: "src/style.css"
      provides: "Custom-styled range input for timeline with fill gradient"
      contains: "input[type=\"range\"]#timeline"
    - path: "src/main.ts"
      provides: "tickCameraAnimation() call in render loop onTick"
      contains: "tickCameraAnimation"
  key_links:
    - from: "src/ui/PlaybackOverlay.ts"
      to: "src/core/cameraPresets.ts"
      via: "setCameraPreset() calls on camera icon button clicks"
      pattern: "setCameraPreset\\("
    - from: "src/ui/PlaybackOverlay.ts"
      to: "src/core/store.ts"
      via: "setPlaybackSpeed/setScrubbing/setPlaying store actions"
      pattern: "appStore\\.getState\\(\\)"
    - from: "src/main.ts"
      to: "src/core/cameraPresets.ts"
      via: "tickCameraAnimation() in onTick render loop"
      pattern: "tickCameraAnimation\\(\\)"
    - from: "src/ui/PlaybackOverlay.ts"
      to: "src/core/animationRef.ts"
      via: "getAnimationController() for timeline scrub sync"
      pattern: "getAnimationController\\(\\)"
---

<objective>
Rebuild the playback controls from a floating two-row overlay into a structured single-row control bar below the 3D canvas, with smooth camera animation, four camera presets (Front/Left/Right/Back), a custom-styled YouTube-like timeline scrubber, and segmented speed buttons.

Purpose: Gives users full playback control (speed, scrubbing, camera angles) for detailed form study — the core Phase 3 deliverable.
Output: Restructured index.html, updated cameraPresets.ts with lerp animation, rewritten PlaybackOverlay.ts targeting the control bar, custom timeline CSS styles, main.ts with camera tick.
</objective>

<execution_context>
@C:/Users/kyles/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/kyles/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-playback-controls/03-CONTEXT.md
@.planning/phases/03-playback-controls/03-RESEARCH.md
@.planning/phases/02-3d-viewer-core/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Restructure HTML layout and add smooth camera preset system</name>
  <files>
    index.html
    src/core/cameraPresets.ts
    src/main.ts
  </files>
  <action>
**index.html changes:**
Wrap the existing `<main id="panel-center">` and a new `<div id="control-bar">` inside a flex-col container so the control bar sits structurally below the 3D canvas (not floating over it). The structure should be:

```html
<!-- Replace the bare <main id="panel-center"> with: -->
<div class="flex-1 flex flex-col min-w-0">
  <main id="panel-center" class="flex-1 relative min-w-0">
    <!-- existing toggle buttons stay here -->
  </main>
  <div id="control-bar" class="flex items-center gap-3 px-4 py-2 bg-surface border-t border-white/5 shrink-0">
    <!-- PlaybackOverlay.ts will populate this -->
  </div>
</div>
```

The existing `#panel-center canvas` CSS rule and ResizeObserver in renderer.ts will automatically handle the canvas resizing when the control bar takes height. No changes needed to the canvas sizing logic.

**src/core/cameraPresets.ts changes:**
1. Rename the `side` preset to `right` (its position `x: 3, y: 1, z: 0` is the right-side view — camera is at positive X)
2. Add a `left` preset: `{ x: -3, y: 1, z: 0 }`
3. The four presets are now: `front`, `left`, `right`, `back` — update `PresetName` type accordingly
4. Add a module-level `_targetPosition: THREE.Vector3 | null = null` for lerp state
5. Change `setCameraPreset()` to set `_targetPosition` instead of snapping camera position directly. Still set `_controls.target.set(0, 0.9, 0)` immediately for look-at.
6. Add `export function tickCameraAnimation(): void` that:
   - Returns early if `_targetPosition` is null or camera/controls not registered
   - Calls `_camera.position.lerp(_targetPosition, 0.18)` (exponential ease-out, ~300ms at 60fps)
   - When `_camera.position.distanceTo(_targetPosition) < 0.005`, snaps to exact position and sets `_targetPosition = null`
   - Does NOT call `_controls.update()` — main.ts already calls it each tick
7. In `registerControls()`, add a `controls.addEventListener('start', () => { _targetPosition = null })` listener so manual OrbitControls dragging cancels any active lerp (prevents camera "fighting" the user)
8. Import THREE at the top for `Vector3` usage

**src/main.ts changes:**
1. Import `tickCameraAnimation` from `'./core/cameraPresets'`
2. In the `createRenderLoop` onTick callback, add `tickCameraAnimation()` call BEFORE the existing `controls.update()` call. The tick function handles its own early-return when no animation is active.

The onTick should look like:
```typescript
const loop = createRenderLoop(renderer, scene, camera, () => {
  tickCameraAnimation()
  controls.update()
  if (animationController && !appStore.getState().isScrubbing) {
    animationController.update()
  }
})
```
  </action>
  <verify>
1. `npx tsc --noEmit` passes with no type errors (PresetName type updated, new exports resolve)
2. `npm run dev` starts — page loads with the control bar visible as an empty strip below the 3D canvas
3. The Three.js canvas still fills the center area correctly above the control bar
  </verify>
  <done>
index.html has flex-col wrapper with #control-bar below #panel-center. cameraPresets.ts exports 4 presets (front/left/right/back) with lerp-based smooth animation via tickCameraAnimation(). main.ts calls tickCameraAnimation() in render loop. OrbitControls drag cancels active lerp.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewrite PlaybackOverlay as single-row control bar with styled timeline</name>
  <files>
    src/ui/PlaybackOverlay.ts
    src/style.css
    src/main.ts
  </files>
  <action>
**src/ui/PlaybackOverlay.ts — full rewrite:**

The function signature stays the same (`mountPlaybackOverlay(container: HTMLElement)`) but the implementation changes. Instead of creating a floating overlay inside `#panel-center`, it now targets the `#control-bar` element that already exists in the HTML.

**Key change in src/main.ts:** Update the `mountPlaybackOverlay` call to target `document.getElementById('control-bar')!` instead of `centerPanel`. This is a one-line change.

**PlaybackOverlay.ts implementation — single-row layout (left to right):**

1. **Play/Pause button** — Round button with play/pause unicode icon. Same store wiring as current (`setPlaying(!isPlaying)`). Slightly smaller than current (w-8 h-8 instead of w-10 h-10) to fit the single row.

2. **Timeline slider** — `<input type="range" id="timeline">` with `class="flex-1"` so it stretches to fill remaining space. The slider:
   - `min="0"`, `step="0.001"`, initial `max="1"`, `value="0"`
   - On `pointerdown`: set `isScrubbing = true` in store
   - On `input`: call `animationController.setTime(parseFloat(slider.value))`
   - On `pointerup` (on **window**, not just slider): set `isScrubbing = false`
   - On window `blur`: set `isScrubbing = false` (guard against tab-away during drag)
   - RAF sync loop updates `slider.value` and `--fill-pct` CSS variable each frame when not scrubbing

   The `--fill-pct` CSS variable controls the filled/unfilled gradient (see style.css task below):
   ```typescript
   function updateSliderFill(slider: HTMLInputElement): void {
     const pct = ((parseFloat(slider.value) - parseFloat(slider.min)) /
                  (parseFloat(slider.max) - parseFloat(slider.min))) * 100
     slider.style.setProperty('--fill-pct', `${pct}%`)
   }
   ```

3. **Speed segmented buttons** — Three buttons: `0.5×`, `1×`, `2×`. Grouped in a `flex gap-1` div. Active button uses filled/highlighted style (`bg-accent/20 text-accent border-accent/30`); inactive buttons are subtle (`bg-surface/80 text-white/70 border-white/10`). Default on load: 1× is active. Wire to `setPlaybackSpeed()`.

4. **Camera preset buttons** — Four buttons in a `flex gap-1` div: F (Front), L (Left), R (Right), B (Back). Use single-character abbreviations in small pill buttons (per research recommendation — unambiguous, readable at 14px, no external resources needed). Wire to `setCameraPreset('front')`, etc. Style consistent with speed buttons (same btnBase class).

5. **Annotation toggle** — Keep the existing Labels toggle button at the end. Same store wiring as current.

6. **Store subscription** — Single `appStore.subscribe()` call updates: play/pause icon, speed button highlights, annotation button highlight.

7. **RAF slider sync** — Same pattern as current but also calls `updateSliderFill()` each frame. Guard: `if (slider.max !== String(dur)) slider.max = String(dur)` handles exercise switches.

8. **Scrubbing safety** — Add `window.addEventListener('pointerup', ...)` and `window.addEventListener('blur', ...)` to clear `isScrubbing` even if pointer leaves the slider (prevents frozen animation on tab-away).

**src/style.css additions:**

Add custom styling for the timeline range input below the existing rules:

```css
/* Timeline scrubber — YouTube seekbar style */
input[type="range"]#timeline {
  -webkit-appearance: none;
  appearance: none;
  height: 4px;
  border-radius: 2px;
  outline: none;
  cursor: pointer;
  background: linear-gradient(
    to right,
    var(--color-accent) 0%,
    var(--color-accent) var(--fill-pct, 0%),
    oklch(35% 0.01 264) var(--fill-pct, 0%),
    oklch(35% 0.01 264) 100%
  );
}

input[type="range"]#timeline::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: white;
  cursor: pointer;
  box-shadow: 0 0 2px rgba(0, 0, 0, 0.3);
}

input[type="range"]#timeline::-moz-range-thumb {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: white;
  border: none;
  cursor: pointer;
  box-shadow: 0 0 2px rgba(0, 0, 0, 0.3);
}
```

The `--fill-pct` CSS custom property is set by JavaScript each RAF frame to show the accent-colored filled portion vs. the gray unfilled portion.

**IMPORTANT — Decisions to honor (from CONTEXT.md):**
- Speed: Segmented buttons [0.5x] [1x] [2x], active gets filled/highlighted background, default 1x
- Camera: Four presets (Front, Left, Right, Back), icons not text (F/L/R/B abbreviation pills qualify per Claude's discretion)
- Timeline: YouTube-like thin seekbar, accent fill, no tooltip, resume on release
- Layout: Play/Pause | Timeline | Speed | Camera presets (left to right), timeline flex-fills remaining space
- Control bar: Subtle different-shade background from viewer area (bg-surface + border-t border-white/5)
- Do NOT store animation time in Zustand — read from AnimationController via RAF (per STATE.md decision)
  </action>
  <verify>
1. `npx tsc --noEmit` passes with no type errors
2. `npm run dev` — control bar shows single row: play/pause circle, styled timeline slider, 0.5×/1×/2× speed buttons, F/L/R/B camera buttons, Labels toggle
3. Click speed buttons — animation speed changes visibly, active button highlights
4. Click camera buttons — camera smoothly animates to preset position (~300ms), no snap
5. Drag timeline slider — animation scrubs frame-by-frame; release resumes playback
6. Timeline slider shows accent-colored fill for played portion
7. Exercise switch — slider resets, new animation plays correctly
8. OrbitControls drag during camera animation — lerp cancels, no "fighting"
  </verify>
  <done>
PlaybackOverlay renders a single-row control bar in #control-bar with all controls laid out per CONTEXT.md spec. Timeline has custom CSS styling with accent fill. Speed buttons highlight active selection. Camera presets use icon-style abbreviation buttons (F/L/R/B). Scrubbing safely handles pointer-up-outside and tab-away edge cases.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — zero type errors
2. `npm run build` — clean production build, no warnings
3. Full control bar visible below 3D canvas with subtle background (not floating over canvas)
4. Play/Pause toggles animation; speed buttons change pace; camera buttons animate smoothly; timeline scrubs and resumes
5. Four camera presets work: Front, Left, Right, Back — each smooth ~300ms transition
6. Existing features preserved: exercise switching, panel collapse, orbit controls, form guide step sync, annotation overlay
</verification>

<success_criteria>
- VIEW-04 met: 0.5×/1×/2× speed buttons change animation pace with visual active state
- VIEW-05 met: Front/Left/Right/Back camera presets animate smoothly to position
- VIEW-06 met: Timeline slider scrubs frame-by-frame and resumes on release with accent-colored fill
- Control bar layout matches CONTEXT.md spec: Play/Pause | Timeline | Speed | Camera presets
- No regressions: exercise switching, panel collapse, orbit controls, form guide all still work
</success_criteria>

<output>
After completion, create `.planning/phases/03-playback-controls/03-01-SUMMARY.md`
</output>
