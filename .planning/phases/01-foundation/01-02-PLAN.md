---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - src/mannequin/mannequin.types.ts
  - src/mannequin/MannequinBuilder.ts
  - src/mannequin/segments/torso.ts
  - src/mannequin/segments/limbs.ts
  - src/mannequin/segments/head.ts
  - src/animation/keyframe-utils.ts
  - src/animation/AnimationController.ts
  - src/exercises/types.ts
  - src/exercises/registry.ts
  - src/exercises/squat.ts
  - src/core/store.ts
  - src/core/renderer.ts
  - src/core/loop.ts
  - src/main.ts
  - CONTRIBUTING.md
autonomous: true
requirements:
  - TECH-01
  - TECH-02

must_haves:
  truths:
    - "The ExerciseDefinition TypeScript interface is defined with all required fields"
    - "At least one exercise (squat) is registered in the exercise registry"
    - "A programmatic mannequin renders in the Three.js scene with visible segmented body parts"
    - "The squat animation plays on loop using QuaternionKeyframeTrack with smooth interpolation"
    - "A developer can add a new exercise by creating one file in exercises/ and following CONTRIBUTING.md"
  artifacts:
    - path: "src/exercises/types.ts"
      provides: "ExerciseDefinition interface and MuscleId type"
      exports: ["ExerciseDefinition", "MuscleId"]
    - path: "src/exercises/registry.ts"
      provides: "Exercise registry map"
      exports: ["exerciseRegistry"]
    - path: "src/exercises/squat.ts"
      provides: "Squat exercise definition with animation keyframes"
      exports: ["squat"]
    - path: "src/mannequin/MannequinBuilder.ts"
      provides: "Programmatic mannequin mesh builder"
      exports: ["buildMannequin", "MannequinRig"]
    - path: "src/mannequin/mannequin.types.ts"
      provides: "Joint and segment name enums"
      exports: ["JointName", "SegmentName"]
    - path: "src/animation/keyframe-utils.ts"
      provides: "Euler-to-quaternion keyframe utilities"
      exports: ["buildQuatTrack", "buildClip"]
    - path: "src/animation/AnimationController.ts"
      provides: "AnimationMixer wrapper"
      exports: ["AnimationController"]
    - path: "src/core/store.ts"
      provides: "Zustand vanilla store"
      exports: ["appStore"]
    - path: "src/core/renderer.ts"
      provides: "Three.js scene, camera, renderer setup"
    - path: "src/core/loop.ts"
      provides: "Render loop with clock"
      exports: ["createRenderLoop"]
    - path: "CONTRIBUTING.md"
      provides: "Step-by-step guide for adding an exercise"
      min_lines: 30
  key_links:
    - from: "src/exercises/squat.ts"
      to: "src/exercises/types.ts"
      via: "implements ExerciseDefinition"
      pattern: "ExerciseDefinition"
    - from: "src/exercises/registry.ts"
      to: "src/exercises/squat.ts"
      via: "imports and registers squat"
      pattern: "import.*squat"
    - from: "src/animation/AnimationController.ts"
      to: "THREE.AnimationMixer"
      via: "wraps mixer with play/pause/speed"
      pattern: "AnimationMixer"
    - from: "src/mannequin/MannequinBuilder.ts"
      to: "src/mannequin/mannequin.types.ts"
      via: "uses JointName enum for Object3D names"
      pattern: "JointName"
    - from: "src/exercises/squat.ts"
      to: "src/animation/keyframe-utils.ts"
      via: "builds animation clip from keyframe data"
      pattern: "buildQuatTrack|buildClip"
    - from: "src/main.ts"
      to: "src/exercises/registry.ts"
      via: "loads exercise from registry"
      pattern: "exerciseRegistry"
    - from: "src/main.ts"
      to: "src/mannequin/MannequinBuilder.ts"
      via: "builds and adds mannequin to scene"
      pattern: "buildMannequin"
---

<objective>
Build the programmatic mannequin mesh hierarchy, the animation system, and the config-driven exercise registry with one working exercise (squat) that plays on loop.

Purpose: Proves the core technical substrate works end-to-end — a programmatically-built mannequin animated via QuaternionKeyframeTrack with exercise data defined in a type-safe registry. This is the foundation every Phase 2-5 feature depends on.
Output: A Three.js scene rendering a segmented mannequin performing a squat on loop, a typed exercise registry with one entry, and a CONTRIBUTING.md documenting how to add new exercises.
</objective>

<execution_context>
@C:/Users/kyles/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/kyles/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build programmatic mannequin and Three.js scene infrastructure</name>
  <files>
    src/mannequin/mannequin.types.ts
    src/mannequin/MannequinBuilder.ts
    src/mannequin/segments/torso.ts
    src/mannequin/segments/limbs.ts
    src/mannequin/segments/head.ts
    src/core/renderer.ts
    src/core/loop.ts
    src/core/store.ts
  </files>
  <action>
Build the programmatic mannequin mesh hierarchy and the Three.js rendering infrastructure.

**1. src/mannequin/mannequin.types.ts:**
- Define `JointName` enum with all joint pivot names that will be used as Object3D.name values AND as animation track path prefixes. Include: pelvis, spine, chest, neck, head, l_shoulder, l_elbow, l_wrist, r_shoulder, r_elbow, r_wrist, l_hip, l_knee, l_ankle, r_hip, r_knee, r_ankle. These names are FROZEN — they become the animation contract.
- Define `SegmentName` enum for highlightable mesh regions: torso, chest, upper_arm_l, upper_arm_r, forearm_l, forearm_r, thigh_l, thigh_r, shin_l, shin_r, head, neck, glutes, lower_back, core_front.

**2. src/mannequin/segments/torso.ts, limbs.ts, head.ts:**
- Factory functions that create mesh groups for each body region.
- Each function creates meshes from Three.js primitives (CylinderGeometry, SphereGeometry, CapsuleGeometry).
- CRITICAL: Each mesh gets its own NEW MeshStandardMaterial instance (color: 0xd0d0d0, roughness: 0.85, metalness: 0.0). Do NOT share material instances between segments — Phase 4 muscle highlighting requires independent material control.
- Use SphereGeometry at joints for smooth visual connections between segments.
- Proportions should approximate a neutral human figure (~1.75m total height). Use realistic joint positions.

**3. src/mannequin/MannequinBuilder.ts:**
- Export `MannequinRig` interface with: root (Object3D), joints (Map<string, Object3D>), segmentMaterials (Map<string, MeshStandardMaterial>).
- Export `buildMannequin()` function that:
  - Creates the full joint Object3D hierarchy (pelvis -> spine -> chest -> etc.)
  - Sets Object3D.name on EVERY joint using JointName enum values (CRITICAL: animation track paths must match exactly)
  - Calls segment factory functions to create meshes and attach to joints
  - Positions joints at anatomically reasonable offsets
  - Collects all segment materials into the Map for later highlighting
  - Returns the MannequinRig
- The mannequin should be centered at origin with feet near y=0.

**4. src/core/renderer.ts:**
- Create and export: WebGLRenderer, Scene, PerspectiveCamera
- Renderer: antialias true, set pixel ratio, dark clear color (0x1a1a1a)
- Camera: FOV ~50, positioned to see full mannequin (~3m back, ~1m up, looking at origin)
- Lighting: One ambient light (soft, low intensity) + one directional light (from upper-right) for the mannequin material to look good
- Append renderer.domElement to a canvas container div
- Handle window resize

**5. src/core/loop.ts:**
- Export `createRenderLoop` function per research pattern
- Takes renderer, scene, camera, and onTick callback
- Uses THREE.Clock.getDelta() for timing (NOT Date.now())
- Returns start/stop controls

**6. src/core/store.ts:**
- Use `createStore` from `zustand/vanilla` (Zustand v5 API — NOT `create`)
- AppState interface: selectedExerciseId (string, default 'squat'), isPlaying (boolean, default true), playbackSpeed (number, default 1.0)
- Actions: setExercise, setPlaying, setPlaybackSpeed
- Export appStore

IMPORTANT: All joint Object3D names MUST use the JointName enum values. Animation tracks reference these by name string — a mismatch causes silent animation failure.
IMPORTANT: Material instances must be separate per segment. Test by checking `segmentMaterials.size` equals the number of independently-highlightable regions.
  </action>
  <verify>
- `npm run build` passes with no TypeScript errors
- `npm run dev` shows the mannequin rendered in the browser against a dark background
- Open browser DevTools console — no errors or warnings
- Visually confirm: a humanoid figure is visible with distinct body segments (not a single blob)
  </verify>
  <done>
A segmented mannequin renders in a Three.js scene against a dark background. Each body segment has its own material instance. All joints are named with JointName enum values. The Zustand store is initialized. The render loop ticks.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create animation system, exercise registry, squat exercise, and CONTRIBUTING.md</name>
  <files>
    src/animation/keyframe-utils.ts
    src/animation/AnimationController.ts
    src/exercises/types.ts
    src/exercises/registry.ts
    src/exercises/squat.ts
    src/main.ts
    CONTRIBUTING.md
  </files>
  <action>
Wire the animation system, define the exercise data contract, register the squat exercise, and document the workflow.

**1. src/animation/keyframe-utils.ts:**
- Export `buildQuatTrack(bonePath: string, keyframes: Array<{time, x, y, z}>)` — converts degree Euler angles to quaternions, returns QuaternionKeyframeTrack. Use ZYX Euler order (biomechanical convention). bonePath MUST end in `.quaternion`.
- Export `buildClip(name: string, tracks: KeyframeTrack[], duration?: number)` — creates AnimationClip (duration -1 for auto).
- Export `deg(d: number)` helper (degrees to radians).

**2. src/animation/AnimationController.ts:**
- Export AnimationController class wrapping THREE.AnimationMixer.
- Constructor takes root Object3D (the mannequin root).
- Methods: play(clip) — stops current action, creates new clipAction, sets LoopRepeat Infinity, plays. update() — calls mixer.update(clock.getDelta()). setSpeed(speed) — sets timeScale. setPaused(paused) — sets paused flag.
- Uses its own THREE.Clock instance for delta timing.

**3. src/exercises/types.ts:**
- Export `MuscleId` type (union of string literals): quads, hamstrings, glutes, calves, chest, front-delts, triceps, lats, traps, rear-delts, biceps, core, lower-back, hip-flexors.
- Export `ExerciseDefinition` interface:
  - id: string
  - name: string (display name)
  - primaryMuscles: MuscleId[]
  - secondaryMuscles: MuscleId[]
  - difficulty: 'beginner' | 'intermediate' | 'advanced' (in schema, not displayed v1)
  - formSteps: string[] (3-5 short coaching cues)
  - commonMistakes: string[] (min 2)
  - hasGhostEquipment: boolean
  - buildAnimation: (rig: MannequinRig) => THREE.AnimationClip

**4. src/exercises/squat.ts:**
- Export `squat` conforming to ExerciseDefinition.
- id: 'squat', name: 'Squat', primaryMuscles: ['quads', 'glutes'], secondaryMuscles: ['hamstrings', 'core', 'lower-back']
- difficulty: 'beginner'
- formSteps: 3-5 concise cues (e.g., "Feet shoulder-width apart, toes slightly out", "Push hips back and bend knees simultaneously", "Descend until thighs are parallel to the floor", "Drive through heels to stand back up", "Keep chest up and core braced throughout")
- commonMistakes: at least 2 (e.g., "Knees caving inward — push knees out over toes", "Rising on toes — keep weight in heels")
- hasGhostEquipment: false
- buildAnimation: function that uses buildQuatTrack to create tracks for both hips, both knees, spine, and pelvis. Biomechanically accurate squat:
  - Duration: ~3 seconds per rep (1.5s down, 1.5s up)
  - Hip flexion: ~90-100 degrees at bottom
  - Knee flexion: ~120-130 degrees at bottom
  - Slight forward lean in spine (~15-20 degrees)
  - Ankles dorsiflex slightly (~15 degrees)
  - Return to neutral at end (same as start for seamless loop)
  - Use smooth timing (not perfectly linear — slightly slower at bottom for realistic feel)

**5. src/exercises/registry.ts:**
- Export `exerciseRegistry` as `Map<string, ExerciseDefinition>`
- Register the squat exercise
- Export a `getExercise(id: string)` helper that returns the definition or throws

**6. Update src/main.ts:**
- Import and build the mannequin (from Task 1)
- Add mannequin root to scene
- Get squat from registry, call buildAnimation(rig) to get the AnimationClip
- Create AnimationController with mannequin root, call play(clip)
- Wire the render loop onTick to call animationController.update()
- Wire Zustand store subscription: when isPlaying changes, call setPaused; when playbackSpeed changes, call setSpeed
- Result: opening the page shows the mannequin performing squats on loop

**7. CONTRIBUTING.md:**
- Title: "Adding a New Exercise to FormCheck"
- Step-by-step guide:
  1. Create a new file in src/exercises/ (e.g., lunge.ts)
  2. Import ExerciseDefinition, MannequinRig, buildQuatTrack, buildClip
  3. Define the exercise object conforming to ExerciseDefinition interface
  4. Define the buildAnimation function with joint keyframes using JointName enum values
  5. Register in src/exercises/registry.ts (import + add to Map)
  6. Reference: list all available JointName values and what they control
  7. Testing: run `npm run dev`, verify animation plays smoothly, check for console errors
  8. Mention: keyframe angles are in degrees (ZYX Euler order), one rep should loop seamlessly (end pose = start pose)
- Include a minimal code template that can be copied

IMPORTANT: Animation track paths MUST use the exact JointName enum string values from mannequin.types.ts followed by ".quaternion". Example: if JointName.L_KNEE = 'l_knee', then track path = 'l_knee.quaternion'.
IMPORTANT: Squat animation must loop seamlessly — the final keyframe pose must match the initial keyframe pose (both at rest/neutral).
IMPORTANT: Use biomechanically accurate angles — this is a sports science reference tool, not a game.
  </action>
  <verify>
- `npm run build` passes with no TypeScript errors
- `npm run dev` shows the mannequin performing a squat on continuous loop
- The squat animation looks biomechanically plausible (knees bend, hips hinge, slight forward lean)
- The animation loops without visible jump or pop (seamless start-to-end transition)
- Open browser console — no errors about animation track mismatches or missing properties
- Verify registry: in browser console, import exerciseRegistry and confirm it has 1 entry with id 'squat'
- CONTRIBUTING.md exists with clear step-by-step instructions and a code template
  </verify>
  <done>
The mannequin performs a biomechanically plausible squat on continuous loop. The ExerciseDefinition TypeScript interface is defined with all required fields. The squat exercise is registered in the registry. CONTRIBUTING.md documents the complete workflow for adding new exercises. A developer (or Claude) can add a new exercise by creating one file in exercises/ and adding one registry entry, following the documented pattern.
  </done>
</task>

</tasks>

<verification>
Overall Plan 02 checks:
1. `npm run build` succeeds with no errors
2. `npm run dev` shows a mannequin performing a squat on loop
3. Animation is smooth (no robotic linear motion, no jumps at loop boundary)
4. ExerciseDefinition interface has: id, name, primaryMuscles, secondaryMuscles, difficulty, formSteps, commonMistakes, hasGhostEquipment, buildAnimation
5. exerciseRegistry.get('squat') returns a valid ExerciseDefinition
6. Each mannequin segment has its own material instance (check: rig.segmentMaterials.size >= 10)
7. CONTRIBUTING.md exists and is clear enough to follow without additional context
</verification>

<success_criteria>
- Mannequin renders as a visible humanoid figure with distinct body segments
- Squat animation plays on continuous loop with smooth motion
- ExerciseDefinition interface is type-safe and complete
- Exercise registry holds at least one exercise (squat)
- CONTRIBUTING.md provides a complete add-exercise workflow with code template
- All joint names match between mannequin builder and animation track paths
- Zustand store controls (play/pause/speed) affect animation playback
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
