---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - src/mannequin/mannequin.types.ts
  - src/mannequin/MannequinBuilder.ts
  - src/mannequin/segments/torso.ts
  - src/mannequin/segments/limbs.ts
  - src/mannequin/segments/head.ts
  - src/core/store.ts
  - src/core/renderer.ts
  - src/core/loop.ts
autonomous: true
requirements:
  - TECH-01

must_haves:
  truths:
    - "A programmatic mannequin renders in the Three.js scene with visible segmented body parts"
    - "Each mannequin segment has its own material instance for independent highlighting"
    - "All joints are named with JointName enum values that match the animation contract"
  artifacts:
    - path: "src/mannequin/mannequin.types.ts"
      provides: "Joint and segment name enums"
      exports: ["JointName", "SegmentName"]
    - path: "src/mannequin/MannequinBuilder.ts"
      provides: "Programmatic mannequin mesh builder"
      exports: ["buildMannequin", "MannequinRig"]
    - path: "src/mannequin/segments/torso.ts"
      provides: "Torso segment mesh factory"
    - path: "src/mannequin/segments/limbs.ts"
      provides: "Arm and leg segment mesh factories"
    - path: "src/mannequin/segments/head.ts"
      provides: "Head and neck segment mesh factory"
    - path: "src/core/store.ts"
      provides: "Zustand vanilla store"
      exports: ["appStore"]
    - path: "src/core/renderer.ts"
      provides: "Three.js scene, camera, renderer setup"
    - path: "src/core/loop.ts"
      provides: "Render loop with clock"
      exports: ["createRenderLoop"]
  key_links:
    - from: "src/mannequin/MannequinBuilder.ts"
      to: "src/mannequin/mannequin.types.ts"
      via: "uses JointName enum for Object3D names"
      pattern: "JointName"
    - from: "src/mannequin/MannequinBuilder.ts"
      to: "src/mannequin/segments/torso.ts"
      via: "calls torso segment factory"
      pattern: "import.*torso"
    - from: "src/mannequin/MannequinBuilder.ts"
      to: "src/mannequin/segments/limbs.ts"
      via: "calls limb segment factories"
      pattern: "import.*limbs"
    - from: "src/mannequin/MannequinBuilder.ts"
      to: "src/mannequin/segments/head.ts"
      via: "calls head segment factory"
      pattern: "import.*head"
---

<objective>
Build the programmatic mannequin mesh hierarchy and Three.js scene rendering infrastructure with Zustand state store.

Purpose: Establishes the visual foundation — a segmented mannequin rendered in a Three.js scene. The mannequin's joint hierarchy and segment materials are the animation contract that all exercises depend on. Getting this right now prevents costly refactoring later.
Output: A Three.js scene rendering a static segmented mannequin against a dark background, with a working render loop, Zustand store, and correctly named joint hierarchy.
</objective>

<execution_context>
@C:/Users/kyles/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/kyles/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create mannequin types, segment factories, and MannequinBuilder</name>
  <files>
    src/mannequin/mannequin.types.ts
    src/mannequin/MannequinBuilder.ts
    src/mannequin/segments/torso.ts
    src/mannequin/segments/limbs.ts
    src/mannequin/segments/head.ts
  </files>
  <action>
Build the programmatic mannequin mesh hierarchy.

**1. src/mannequin/mannequin.types.ts:**
- Define `JointName` enum with all joint pivot names that will be used as Object3D.name values AND as animation track path prefixes. Include: pelvis, spine, chest, neck, head, l_shoulder, l_elbow, l_wrist, r_shoulder, r_elbow, r_wrist, l_hip, l_knee, l_ankle, r_hip, r_knee, r_ankle. These names are FROZEN — they become the animation contract.
- Define `SegmentName` enum for highlightable mesh regions: torso, chest, upper_arm_l, upper_arm_r, forearm_l, forearm_r, thigh_l, thigh_r, shin_l, shin_r, head, neck, glutes, lower_back, core_front.

**2. src/mannequin/segments/torso.ts, limbs.ts, head.ts:**
- Factory functions that create mesh groups for each body region.
- Each function creates meshes from Three.js primitives (CylinderGeometry, SphereGeometry, CapsuleGeometry).
- CRITICAL: Each mesh gets its own NEW MeshStandardMaterial instance (color: 0xd0d0d0, roughness: 0.85, metalness: 0.0). Do NOT share material instances between segments — Phase 4 muscle highlighting requires independent material control.
- Use SphereGeometry at joints for smooth visual connections between segments.
- Proportions should approximate a neutral human figure (~1.75m total height). Use realistic joint positions.

**3. src/mannequin/MannequinBuilder.ts:**
- Export `MannequinRig` interface with: root (Object3D), joints (Map<string, Object3D>), segmentMaterials (Map<string, MeshStandardMaterial>).
- Export `buildMannequin()` function that:
  - Creates the full joint Object3D hierarchy (pelvis -> spine -> chest -> etc.)
  - Sets Object3D.name on EVERY joint using JointName enum values (CRITICAL: animation track paths must match exactly)
  - Calls segment factory functions to create meshes and attach to joints
  - Positions joints at anatomically reasonable offsets
  - Collects all segment materials into the Map for later highlighting
  - Returns the MannequinRig
- The mannequin should be centered at origin with feet near y=0.

IMPORTANT: All joint Object3D names MUST use the JointName enum values. Animation tracks reference these by name string — a mismatch causes silent animation failure.
IMPORTANT: Material instances must be separate per segment. Test by checking `segmentMaterials.size` equals the number of independently-highlightable regions.
  </action>
  <verify>
- `npm run build` passes with no TypeScript errors
- Manually inspect mannequin.types.ts exports JointName and SegmentName enums
- Manually inspect MannequinBuilder.ts exports buildMannequin and MannequinRig
  </verify>
  <done>
MannequinBuilder produces a segmented mannequin with all joints named per JointName enum. Each body segment has its own material instance. The MannequinRig interface provides access to root, joints map, and segmentMaterials map.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Three.js scene infrastructure, render loop, Zustand store, and wire mannequin</name>
  <files>
    src/core/renderer.ts
    src/core/loop.ts
    src/core/store.ts
    src/main.ts
  </files>
  <action>
Build the Three.js rendering infrastructure and wire it to display the mannequin.

**1. src/core/renderer.ts:**
- Create and export: WebGLRenderer, Scene, PerspectiveCamera
- Renderer: antialias true, set pixel ratio, dark clear color (0x1a1a1a)
- Camera: FOV ~50, positioned to see full mannequin (~3m back, ~1m up, looking at origin)
- Lighting: One ambient light (soft, low intensity) + one directional light (from upper-right) for the mannequin material to look good
- Append renderer.domElement to a canvas container div
- Handle window resize

**2. src/core/loop.ts:**
- Export `createRenderLoop` function per research pattern
- Takes renderer, scene, camera, and onTick callback
- Uses THREE.Clock.getDelta() for timing (NOT Date.now())
- Returns start/stop controls

**3. src/core/store.ts:**
- Use `createStore` from `zustand/vanilla` (Zustand v5 API — NOT `create`)
- AppState interface: selectedExerciseId (string, default 'squat'), isPlaying (boolean, default true), playbackSpeed (number, default 1.0)
- Actions: setExercise, setPlaying, setPlaybackSpeed
- Export appStore

**4. Update src/main.ts:**
- Import renderer setup (scene, camera, renderer from renderer.ts)
- Import and call buildMannequin(), add mannequin root to scene
- Create render loop, start it
- The mannequin should be visible in the browser as a static figure (animation comes in Plan 03)
- Keep any placeholder text minimal — the 3D canvas is the focus now

IMPORTANT: Use Zustand v5 `createStore` from `zustand/vanilla`, NOT `create`.
IMPORTANT: Clock.getDelta() for timing, not Date.now().
  </action>
  <verify>
- `npm run build` passes with no TypeScript errors
- `npm run dev` shows the mannequin rendered in the browser against a dark background
- Open browser DevTools console — no errors or warnings
- Visually confirm: a humanoid figure is visible with distinct body segments (not a single blob)
  </verify>
  <done>
A segmented mannequin renders in a Three.js scene against a dark background. The render loop ticks. The Zustand store is initialized with default state. Each body segment has its own material instance. All joints are named with JointName enum values.
  </done>
</task>

</tasks>

<verification>
Overall Plan 02 checks:
1. `npm run build` succeeds with no errors
2. `npm run dev` shows a mannequin rendered in the browser
3. Mannequin appears as a humanoid figure with distinct body segments
4. Each mannequin segment has its own material instance (check: rig.segmentMaterials.size >= 10)
5. All joint Object3D.name values match JointName enum strings
6. Zustand store exports appStore with selectedExerciseId, isPlaying, playbackSpeed
7. Render loop ticks without errors
</verification>

<success_criteria>
- Mannequin renders as a visible humanoid figure with distinct body segments
- Each body segment has its own MeshStandardMaterial instance
- All joint names match JointName enum values (frozen animation contract)
- Zustand store is initialized with correct defaults
- Render loop runs smoothly with no console errors
- npm run build passes cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
